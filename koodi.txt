Sammonsiru.ino
---------------
#include <math.h>


/* 
  Sketch generated by the Arduino IoT Cloud Thing "Sammonsiru"
  https://create.arduino.cc/cloud/things/d2ed9806-4ff5-47fb-9f4f-b3e98d19ab56 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float lampotila;
  int kosteus_yhteensa;
  int valo;
  bool kastelee;
  bool vetta_sisalla;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
//kello

#include "RTC.h"

//Include the NTP library
int tunti;
#include <NTPClient.h>

#if defined(ARDUINO_PORTENTA_C33)
#include <WiFiC3.h>
#elif defined(ARDUINO_UNOWIFIR4)
#include <WiFiS3.h>
#endif

#include <WiFiUdp.h>
#include "kello_secrets.h" 


char ssid[] = SECRET_SSID;        // your network SSID (name)
char pass[] = SECRET_PASS;    // your network password (use for WPA, or use as key for WEP)

int wifiStatus = WL_IDLE_STATUS;
WiFiUDP Udp; // A UDP instance to let us send and receive packets over UDP
NTPClient timeClient(Udp);






//muu
#include "thingProperties.h"

int kosteus_3;
int a;
int B=4275;                  //B value of the thermistor
float resistance;
bool valot;
int kosteus_1;
int kosteus_2;
int alusta;
int viime_aika;
int tulevaan;
int vali_aika;
int alku_muuttuva;
int mennyt;
bool lupa;


void setup() {
  kastelee=false;
  vali_aika=300000;   //1800000
  lupa=true;
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  delay(1500); 
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  pinMode(2, OUTPUT); //pumppu 1
  pinMode(3, OUTPUT); //pumppu 2
  pinMode(4, OUTPUT); //puna
  pinMode(5, OUTPUT); // kelta
  pinMode(6, OUTPUT); // vihreä
  pinMode(7, OUTPUT); // sini
  pinMode(A0, INPUT);
  pinMode(A1, INPUT);
  pinMode(A2, INPUT);
  pinMode(A3, INPUT);
  pinMode(A4, INPUT);
  pinMode(10, INPUT);
  
  digitalWrite(4, HIGH); //puna
  digitalWrite(5, HIGH); //kelta
  digitalWrite(6, HIGH); //vihreä
  digitalWrite(7, HIGH); //sini
  delay(3000); 
  digitalWrite(4, LOW); //puna
  digitalWrite(5, LOW); //kelta
  digitalWrite(6, LOW); //vihreä
  digitalWrite(7, LOW);


  //kello
  while (!Serial);
  
  connectToWiFi();
  RTC.begin();
  Serial.println("\nStarting connection to server...");
  timeClient.begin();
  timeClient.update();

  // Get the current date and time from an NTP server and convert
  // it to UTC +2 by passing the time zone offset in hours.
  // You may change the time zone offset to your local one.
  auto timeZoneOffsetHours = 2;
  auto unixTime = timeClient.getEpochTime() + (timeZoneOffsetHours * 3600);
  Serial.print("Unix time = ");
  Serial.println(unixTime);
  RTCTime timeToSet = RTCTime(unixTime);
  RTC.setTime(timeToSet);

  // Retrieve the date and time from the RTC and print them
  RTCTime currentTime;
  RTC.getTime(currentTime); 
  Serial.println("The RTC was just set to: " + String(currentTime));






  
  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  Serial.println("lupa");


  //kello
  tunti = 0;
  katso_tunti();
  alusta=millis();
  //kastelu aika

  alku_muuttuva=alusta;
  mennyt=alku_muuttuva-viime_aika;
  //Serial.println(mennyt);
  if(mennyt>vali_aika)
  {
    lupa=true;
    Serial.println("lupa");



  }



  //kastelee=true;
  Serial.println(valot);
  Serial.println(kastelee);
  Serial.println(lupa);
  ArduinoCloud.update();
  a=analogRead(A3);
  resistance=(float)(1023-a)*10000/a; //get the resistance of the sensor;
  lampotila=1/(log(resistance/10000)/B+1/298.15)-273.15;//convert to temperature via datasheet&nbsp;;
  kosteus_yhteensa = ((kosteus_1 + kosteus_2) / 2);
  //Serial.println(kosteus_yhteensa);
  kosteus_1 = analogRead(A0);
  kosteus_2 = analogRead(A1);
  kosteus_3 = analogRead(A2);
  valo = analogRead(A4);
  // put your main code here, to run repeatedly:
  digitalWrite(2, LOW); //pumppu 1
  digitalWrite(3, LOW); //pumppu 2
  digitalWrite(4, LOW); //puna
  digitalWrite(5, LOW); //kelta
  digitalWrite(6, LOW); //vihreä
  digitalWrite(7, LOW); //sini
  if(digitalRead(10) == HIGH)
  {
    digitalWrite(2, HIGH); //pumppu 1
    digitalWrite(3, HIGH); //pumppu 2
    digitalWrite(7, HIGH);
    delay(1000); 
    digitalWrite(2, LOW); //pumppu 1
    digitalWrite(3, LOW);
    digitalWrite(7, LOW); 





  }
  if (kosteus_yhteensa > 500 && valot==true) {
    digitalWrite(4, HIGH);
    Serial.println("puna");
    
  }
  if (kosteus_yhteensa > 400 && kosteus_yhteensa < 500 && valot==true) {
    digitalWrite(5, HIGH);
    Serial.println("kelta");
  }
  if (kosteus_yhteensa > 400 && valot==true) {
    digitalWrite(6, HIGH);
    Serial.println("vihreä");
    
    
  }
  if(kosteus_yhteensa > 350 && valo>20 )
  {


    
    kastelee=true;
    Serial.println("kastelee_annettu");



    
    

  }
  if(kastelee==true && lupa==true && valot==true)
  {
    
    viime_aika=millis();
    Serial.println("kastelee");
    digitalWrite(2, HIGH); //pumppu 1
    digitalWrite(3, HIGH); //pumppu 2
    digitalWrite(7, HIGH);
    delay(2500); 
    digitalWrite(2, LOW); //pumppu 1
    digitalWrite(3, LOW);
    digitalWrite(7, LOW); 
    lupa=false;
    kastelee=false;
  }







  if(kosteus_3<300)
  {
    vetta_sisalla=true;

  }
  if(kosteus_3>300)
  {
    vetta_sisalla=false;
    

  }
  






}

void onKasteleeChange()  
  {




  }

void onValoChange()  {
  
}






//kello

void katso_tunti()
{
  auto timeZoneOffsetHours = 2;
  auto unixTime = timeClient.getEpochTime() + (timeZoneOffsetHours * 3600);
  Serial.print("Unix time = ");
  Serial.println(unixTime);
  RTCTime timeToSet = RTCTime(unixTime);
  RTC.setTime(timeToSet);

  // Retrieve the date and time from the RTC and print them
  RTCTime currentTime;
  RTC.getTime(currentTime); 
  Serial.println("The RTC was just set to: " + String(currentTime));
  RTC.getTime(currentTime); 
  tunti = currentTime.getHour();
  Serial.println(tunti);
  if(tunti>21 || tunti<7)
  {
    valot=false;
    Serial.println("pois");


  }
  else
  {
    valot=true;
    Serial.println("päällä");

  }




}

void printWifiStatus() {
  // print the SSID of the network you're attached to:
  Serial.print("SSID: ");
  Serial.println(WiFi.SSID());

  // print your board's IP address:
  IPAddress ip = WiFi.localIP();
  Serial.print("IP Address: ");
  Serial.println(ip);

  // print the received signal strength:
  long rssi = WiFi.RSSI();
  Serial.print("signal strength (RSSI):");
  Serial.print(rssi);
  Serial.println(" dBm");
}

void connectToWiFi(){
  // check for the WiFi module:
  if (WiFi.status() == WL_NO_MODULE) {
    Serial.println("Communication with WiFi module failed!");
    // don't continue
    while (true);
  }

  String fv = WiFi.firmwareVersion();
  if (fv < WIFI_FIRMWARE_LATEST_VERSION) {
    Serial.println("Please upgrade the firmware");
  }

  // attempt to connect to WiFi network:
  while (wifiStatus != WL_CONNECTED) {
    Serial.print("Attempting to connect to SSID: ");
    Serial.println(ssid);
    // Connect to WPA/WPA2 network. Change this line if using open or WEP network:
    wifiStatus = WiFi.begin(ssid, pass);

    // wait 10 seconds for connection:
    delay(10000);
  }

  Serial.println("Connected to WiFi");
  printWifiStatus();
}




